buildscript {
  ext.getExtOrDefault = {name ->
    return rootProject.ext.has(name) ? rootProject.ext.get(name) : project.properties['NitroFetch_' + name]
  }

  repositories {
    google()
    mavenCentral()
  }

  dependencies {
    classpath "com.android.tools.build:gradle:8.7.2"
    // noinspection DifferentKotlinGradleVersion
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${getExtOrDefault('kotlinVersion')}"
  }
}

def reactNativeArchitectures() {
  def value = rootProject.getProperties().get("reactNativeArchitectures")
  return value ? value.split(",") : ["armeabi-v7a", "x86", "x86_64", "arm64-v8a"]
}

apply plugin: "com.android.library"
apply plugin: "kotlin-android"
apply from: '../nitrogen/generated/android/nitrofetch+autolinking.gradle'

// Do not apply React Gradle plugin in library to avoid RN codegen duplicating app classes

def getExtOrIntegerDefault(name) {
  return rootProject.ext.has(name) ? rootProject.ext.get(name) : (project.properties["NitroFetch_" + name]).toInteger()
}

android {
  namespace "com.margelo.nitro.nitrofetch"

  compileSdkVersion getExtOrIntegerDefault("compileSdkVersion")

  defaultConfig {
    minSdkVersion getExtOrIntegerDefault("minSdkVersion")
    targetSdkVersion getExtOrIntegerDefault("targetSdkVersion")

    externalNativeBuild {
      cmake {
        cppFlags "-frtti -fexceptions -Wall -fstack-protector-all"
        // Pass CRONET_ROOT so CMake can find headers/libs prepared by Gradle task
        arguments "-DANDROID_STL=c++_shared", "-DANDROID_SUPPORT_FLEXIBLE_PAGE_SIZES=ON", "-DCRONET_ROOT=${buildDir}/cronet"
        abiFilters (*reactNativeArchitectures())

        buildTypes {
          debug {
            cppFlags "-O1 -g"
          }
          release {
            cppFlags "-O2"
          }
        }
      }
    }
  }

  externalNativeBuild {
    cmake {
      path "CMakeLists.txt"
    }
  }

  packagingOptions {
    excludes = [
            "META-INF",
            "META-INF/**",
            "**/libc++_shared.so",
            "**/libfbjni.so",
            "**/libjsi.so",
            "**/libfolly_json.so",
            "**/libfolly_runtime.so",
            "**/libglog.so",
            "**/libhermes.so",
            "**/libhermes-executor-debug.so",
            "**/libhermes_executor.so",
            "**/libreactnative.so",
            "**/libreactnativejni.so",
            "**/libturbomodulejsijni.so",
            "**/libreact_nativemodule_core.so",
            "**/libjscexecutor.so"
    ]
  }

  buildFeatures {
    buildConfig true
    prefab true
  }

  buildTypes {
    release {
      minifyEnabled false
    }
  }

  lintOptions {
    disable "GradleCompatible"
  }

  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }

  sourceSets {
    main {
      java.srcDirs += [
        "generated/java",
        "generated/jni"
      ]
    }
  }
}

repositories {
  mavenCentral()
  google()
}

def kotlin_version = getExtOrDefault("kotlinVersion")
// ---------- Cronet AAR extraction to provide native libs + headers for CMake ----------
def cronetVersion = (getExtOrDefault("cronetVersion") ?: "119.6045.31")
def gmsCronetVersion = (getExtOrDefault("gmsCronetVersion") ?: "18.0.1")
def cronetZipPath = (getExtOrDefault("cronetZip") ?: null) // absolute path to prebuilt cronet_package zip
def cronetLibsDir = (getExtOrDefault("cronetLibsDir") ?: null) // optional local dir with libs/<abi>/libcronet*.so
def cronetRequireCApi = ((getExtOrDefault("requireCApi") ?: "false").toString()).toBoolean() // fail if libs missing


dependencies {
  implementation "com.facebook.react:react-android"
  implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
  implementation project(":react-native-nitro-modules")
  // Provide org.chromium.net Java API for CronetEngine in Kotlin
  implementation "org.chromium.net:cronet-api:${cronetVersion}"
}

configurations {
  cronetAar
}

dependencies {
  // Use Maven artifact to obtain native .so files; not bundled into our AAR automatically.
  if (cronetVersion != null) {
    cronetAar "org.chromium.net:cronet-embedded:${cronetVersion}"
  }
}

def cronetRoot = "$buildDir/cronet"
def cronetAarDir = "$buildDir/cronet/aar"

tasks.register("prepareCronet") {
  group = "nitrofetch"
  description = "Download Cronet AAR and extract .so + headers for CMake"
  outputs.dir(cronetRoot)
  doLast {
    logger.lifecycle("[prepareCronet] cronetRoot=${cronetRoot}")
    logger.lifecycle("[prepareCronet] cronetVersion=${cronetVersion ?: '<unset>'}, gmsCronetVersion=${gmsCronetVersion}, cronetZip=${cronetZipPath ?: '<unset>'}, cronetLibsDir=${cronetLibsDir ?: '<unset>'}, requireCApi=${cronetRequireCApi}")
    File aar = null
    boolean extractedLibs = false

    // Option 1: Use a local prebuilt cronet_package zip if provided
    if (cronetZipPath != null) {
      def zipFile = file(cronetZipPath)
      if (!zipFile.exists()) throw new GradleException("NitroFetch_cronetZip path does not exist: ${cronetZipPath}")
      def tmp = file("${buildDir}/cronet/package"); tmp.mkdirs()
      logger.lifecycle("[prepareCronet] Using prebuilt cronet zip: ${zipFile}")
      copy { from zipTree(zipFile); into tmp }
      // Expect include/ and libs/<abi>
      if (file("${tmp}/include").exists()) {
        copy { from file("${tmp}/include"); into file("${cronetRoot}/include") }
        logger.lifecycle("[prepareCronet] Copied headers from zip -> ${cronetRoot}/include")
      }
      def abis = reactNativeArchitectures()
      abis.each { abi ->
        def src = file("${tmp}/libs/${abi}")
        if (src.exists()) {
          copy { from src; into file("${cronetRoot}/libs/${abi}"); include "*.so" }
          logger.lifecycle("[prepareCronet] Copied libs for ABI ${abi} from zip -> ${cronetRoot}/libs/${abi}")
          extractedLibs = true
        } else {
          logger.lifecycle("[prepareCronet] Zip missing libs for ABI ${abi}")
        }
      }
      if (!extractedLibs) logger.warn("Prebuilt cronet zip did not contain native libs for configured ABIs")
    }

    // Option 2: Resolve an AAR providing Cronet native libs.
    if (!extractedLibs) {
      if (cronetVersion != null) {
        try {
          def files1 = configurations.cronetAar.resolve()
          if (!files1.isEmpty()) {
            aar = files1.iterator().next()
            logger.lifecycle("[prepareCronet] Resolved org.chromium.net:cronet-embedded:${cronetVersion} -> ${aar}")
          } else {
            logger.lifecycle("[prepareCronet] No files resolved for cronet-embedded:${cronetVersion}")
          }
        } catch (Throwable ignored) {}
      }


      if (aar != null) {
        // Extract AAR into a temporary dir to avoid permission issues in ${buildDir}/cronet/aar
        def tmpExtract = new File(temporaryDir, "aar"); tmpExtract.mkdirs()
        logger.lifecycle("[prepareCronet] Extracting AAR to temp: ${tmpExtract}")
        copy { from zipTree(aar); into tmpExtract }
        def abis = reactNativeArchitectures()
        abis.each { abi ->
          def src = new File(tmpExtract, "jni/${abi}")
          def dst = file("${cronetRoot}/libs/${abi}")
          if (src.exists()) {
            copy { from src; into dst; include "*.so" }
            logger.lifecycle("[prepareCronet] Copied libs for ABI ${abi} from AAR -> ${dst}")
            extractedLibs = true
          } else {
            logger.lifecycle("[prepareCronet] AAR missing libs for ABI ${abi}")
          }
        }
        if (!extractedLibs) {
          logger.warn("[prepareCronet] Resolved AAR did not contain native Cronet .so files. C API linking will be disabled; JS fallback will be used.")
        }
      } else if (!extractedLibs) {
        logger.warn("[prepareCronet] No Cronet AAR resolved and no prebuilt zip provided. C API linking will be disabled; JS fallback will be used.")
      }
    }

    // Option 3: Copy from a local libs directory with ABI subfolders
    if (!extractedLibs && cronetLibsDir != null) {
      def base = file(cronetLibsDir)
      if (!base.exists()) {
        logger.warn("[prepareCronet] cronetLibsDir does not exist: ${base}")
      } else {
        def abis = reactNativeArchitectures()
        abis.each { abi ->
          def src = new File(base, "${abi}")
          if (src.exists()) {
            def dst = file("${cronetRoot}/libs/${abi}")
            copy { from src; into dst; include "libcronet*.so" }
            def copied = dst.listFiles(new FilenameFilter() { boolean accept(File d, String n) { n.startsWith('libcronet') && n.endsWith('.so') } })
            logger.lifecycle("[prepareCronet] Copied ${copied?.size() ?: 0} libs for ABI ${abi} from cronetLibsDir -> ${dst}")
            if (copied && copied.size() > 0) extractedLibs = true
          } else {
            logger.lifecycle("[prepareCronet] cronetLibsDir missing ABI ${abi}")
          }
        }
      }
    }

    // Detect Cronet version from lib filename if possible (e.g., libcronet.122.0.6261.69.so)
    String detectedVersion = null
    // First try temp AAR extraction area
    def tmpScanDir = new File(temporaryDir, "aar")
    def anyAbiTmp = reactNativeArchitectures().find { new File(tmpScanDir, "jni/${it}").exists() }
    if (anyAbiTmp != null) {
      def libDir = new File(tmpScanDir, "jni/${anyAbiTmp}")
      def candidate = libDir.listFiles(new FilenameFilter() {
        boolean accept(File dir, String name) { return name.startsWith("libcronet.") && name.endsWith(".so") }
      })?.find { it }
      if (candidate != null) {
        def m = (candidate.name =~ /libcronet\.([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)/)
        if (m.find()) detectedVersion = m.group(1)
      }
    }
    // If still unknown, scan the destination libs under cronetRoot (covers cronetLibsDir and zip paths)
    if (detectedVersion == null) {
      def anyAbiDst = reactNativeArchitectures().find { new File("${cronetRoot}/libs/${it}").exists() }
      if (anyAbiDst != null) {
        def libDir2 = new File("${cronetRoot}/libs/${anyAbiDst}")
        def candidate2 = libDir2.listFiles(new FilenameFilter() {
          boolean accept(File dir, String name) { return name.startsWith('libcronet.') && name.endsWith('.so') }
        })?.find { it }
        if (candidate2 != null) {
          def m2 = (candidate2.name =~ /libcronet\.([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)/)
          if (m2.find()) detectedVersion = m2.group(1)
        }
      }
    }
    logger.lifecycle("[prepareCronet] Detected Cronet version from libs: ${detectedVersion ?: '<unknown>'}")

    // Fetch C headers into include/cronet (best effort). Try multiple origins and generated header location.
    def includeDir = file("${cronetRoot}/include/cronet"); includeDir.mkdirs()
    def headerRef = detectedVersion ?: (cronetVersion ?: "main")
    def downloadTo = { String url, File outFile ->
      try {
        new URL(url).withInputStream { is ->
          byte[] bytes = is.bytes
          if (url.contains('chromium.googlesource.com') && url.contains('format=TEXT')) {
            def decoded = java.util.Base64.decoder.decode(bytes)
            outFile.bytes = decoded
          } else {
            outFile.bytes = bytes
          }
        }
        logger.lifecycle("[prepareCronet] Downloaded header: ${url} -> ${outFile}")
        return true
      } catch (Throwable t) {
        logger.warn("[prepareCronet] Failed to download ${url}: ${t.message}")
        return false
      }
    }

    def headerSpecs = [
      [ name: 'cronet_c.h', paths: [
        "https://raw.githubusercontent.com/chromium/chromium/${headerRef}/components/cronet/native/cronet_c.h",
        "https://raw.githubusercontent.com/chromium/chromium/${headerRef}/components/cronet/native/include/cronet_c.h",
        "https://chromium.googlesource.com/chromium/src/+/${headerRef}/components/cronet/native/cronet_c.h?format=TEXT",
        "https://chromium.googlesource.com/chromium/src/+/${headerRef}/components/cronet/native/include/cronet_c.h?format=TEXT",
      ]],
      [ name: 'cronet_export.h', paths: [
        "https://raw.githubusercontent.com/chromium/chromium/${headerRef}/components/cronet/native/cronet_export.h",
        "https://raw.githubusercontent.com/chromium/chromium/${headerRef}/components/cronet/native/include/cronet_export.h",
        "https://chromium.googlesource.com/chromium/src/+/${headerRef}/components/cronet/native/cronet_export.h?format=TEXT",
        "https://chromium.googlesource.com/chromium/src/+/${headerRef}/components/cronet/native/include/cronet_export.h?format=TEXT",
      ]],
      [ name: 'cronet.idl_c.h', paths: [
        "https://raw.githubusercontent.com/chromium/chromium/${headerRef}/components/cronet/native/generated/cronet.idl_c.h",
        "https://chromium.googlesource.com/chromium/src/+/${headerRef}/components/cronet/native/generated/cronet.idl_c.h?format=TEXT",
      ]],
    ]
    int downloaded = 0
    headerSpecs.each { spec ->
      File out = new File(includeDir, spec.name)
      boolean got = false
      spec.paths.each { u -> if (!got) got = downloadTo(u, out) }
      if (got) downloaded++
    }

    // Also try to fetch all generated headers from googlesource directory listing, regardless of previous downloads
    try {
      def listingUrl = "https://chromium.googlesource.com/chromium/src/+/${headerRef}/components/cronet/native/generated/?format=JSON"
      logger.lifecycle("[prepareCronet] Fetching generated headers listing: ${listingUrl}")
      def raw = new URL(listingUrl).text
      if (raw.startsWith(")]}\'")) raw = raw.substring(5)
      def json = new groovy.json.JsonSlurper().parseText(raw)
      def entries = (json?.entries ?: [])
      if (entries) {
        int count = 0
        entries.each { e ->
          if ((e?.type == 'blob' || e?.mode == '100644') && e?.name?.endsWith('.h')) {
            def fileUrl = "https://chromium.googlesource.com/chromium/src/+/${headerRef}/components/cronet/native/generated/${e.name}?format=TEXT"
            File outGen = new File(includeDir, e.name as String)
            if (downloadTo(fileUrl, outGen)) count++
          }
        }
        logger.lifecycle("[prepareCronet] Downloaded ${count} generated headers into ${includeDir}")
      } else {
        logger.warn("[prepareCronet] No entries in generated headers listing for ref ${headerRef}")
      }
    } catch (Throwable t) {
      logger.warn("[prepareCronet] Failed to fetch generated headers listing: ${t.message}")
    }

    if (downloaded == 0) {
      logger.warn("[prepareCronet] No headers downloaded. Provide NitroFetch_cronetHeadersZip or NitroFetch_cronetZip, or place headers under ${cronetRoot}/include/cronet (cronet_c.h, cronet.idl_c.h, cronet_export.h)")
    }

    // Summary
    def presentAbis = reactNativeArchitectures().findAll { new File("${cronetRoot}/libs/${it}").exists() }
    logger.lifecycle("[prepareCronet] Summary: headersDir=${cronetRoot}/include, libsAbis=${presentAbis}")
    if (cronetRequireCApi && presentAbis.isEmpty()) {
      throw new GradleException("[prepareCronet] Cronet C API libs not found (set NitroFetch_requireCApi=false to skip)")
    }
  }
}

// Ensure native builds depend on Cronet prep
afterEvaluate {
  tasks.matching { it.name.startsWith("externalNativeBuild") }.configureEach {
    dependsOn("prepareCronet")
  }
}

// Optional: fetch only headers (no AAR extraction)
tasks.register("fetchCronetHeaders") {
  group = "nitrofetch"
  description = "Download Cronet C headers into ${buildDir}/cronet/include/cronet"
  doLast {
    logger.lifecycle("[fetchCronetHeaders] targetDir=${buildDir}/cronet/include/cronet, version=${cronetVersion}")
    def includeDir = file("${buildDir}/cronet/include/cronet"); includeDir.mkdirs()
    def version = cronetVersion
    def urls = [
      "https://raw.githubusercontent.com/chromium/chromium/${version}/components/cronet/native/cronet_c.h",
      "https://raw.githubusercontent.com/chromium/chromium/${version}/components/cronet/native/cronet_export.h",
    ]
    urls.each { u ->
      try {
        new URL(u).withInputStream { i ->
          def name = u.tokenize('/')[-1]
          new File(includeDir, name).bytes = i.bytes
        }
        logger.lifecycle("[fetchCronetHeaders] Downloaded ${u}")
      } catch (Throwable t) {
        logger.warn("[fetchCronetHeaders] Failed to download ${u}: ${t.message}")
      }
    }
  }
}
